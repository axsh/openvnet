<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript">
    window.addEventListener("load", function(evt) {

      var output = document.getElementById("output");
      var input = document.getElementById("input");
      var ws;

      var print = function(message) {
        var d = document.createElement("div");
        d.innerHTML = message;
        /* output.innerHTML=""; */
        output.appendChild(d);
      };

      openWS(evt);

      function openWS(evt) {
        if (ws) {
          print("Websocket still open; nothing to be done.");
          return false;
        }
        var loc = window.location, new_uri;
        /* if (loc.protocol === "https:") { */
        new_uri = "wss:";
        /* } else { */
        /* new_uri = "ws:"; */
        /* } */
        new_uri += "//" + loc.host;
        new_uri += loc.pathname + "pcap";
        ws = new WebSocket(new_uri);
        ws.onopen = function(evt) {
          print("Websocket opened");
        }

        ws.onclose = function(evt) {
          print("Websocket closed");
          ws = null;
        }

        ws.onmessage = function(evt) {
          function parseResponse(object) {
            var out = '';
            for (property in object) if (object.hasOwnProperty(property)) {
              if (object[property] === undefined || object[property] === null) {
                out += property + ':' + object[property] + '<br>';
              } else {
                if (object[property].constructor === Object || object[property].constructor === Array) {
                  out += '<br>' + property + ':<br>';
                  out += parseResponse(object[property]);
                } else {
                  if (property === "payload" || property === "contents" ||
                      property === "SrcMAC" || property === "DstMAC" ||
                      property === "OptionData" || property === "Options" ||
                      property === "Padding" || property === "SourceHwAddress" ||
                      property === "DstHwAddress" || property === "SourceProtAddress" ||
                      property === "DstProtAddress"
                  ) {
                    var rawBytes = atob(object[property]);
                    var hex = '';
                    for ( i = 0; i < rawBytes.length; i++ ) {
                      var oneHex = rawBytes.charCodeAt(i).toString(16)
                      hex += (oneHex.length==2?oneHex:'0'+oneHex);
                    }
                    out += property + ':' + hex + '<br>';
                    /* if (property === "Truncated" && object[property] === "true"){ */
                    /* out += "TRUNCATED" + '<br>'; */
                  } else {
                    out += property + ':' + object[property] + '<br>';
                  }
                }
              }
            }
            return out;
          }
          var toPrint;
          try {
            toPrint=parseResponse(JSON.parse(evt.data));
          } catch (e) {
            //if (e === errIndicatingInvalidJSON){
            toPrint=evt.data;
            //} else { handle whatever other error is in e }
          }
          print("Received response: " + '<br><br>' + toPrint);

          /* print("Received from server: " + evt.data); */
        }

        ws.onerror = function(evt) {
          print("ERROR: " + evt.data);
        }

        return false;
      }


      document.getElementById("open").onclick = function(evt) {
        return openWS(evt);
      };

      document.getElementById("send").onclick = function(evt) {
        if (!ws) {
          print("No open websocket. Opening one now; please try again.")
          return openWS(evt);
        }
        var fullObj = {
          "requestID":requestID.value,
          "filter":filter.value,
          "snapshotLen": parseInt(snapshotLen.value, 10),
          "promiscuous":JSON.parse(promiscuous.value),
          "timeout":parseInt(timeout.value),
          "limit":parseInt(limit.value),
          "ifaceToRead":ifaceToRead.value,
          "readFile":readFile.value,
          "writeFile":writeFile.value,
          "sendRawPacket":JSON.parse(sendRawPacket.value),
          "sendMetadata":JSON.parse(sendMetadata.value),
          "decodePacket":JSON.parse(decodePacket.value),
          "decodeProtocolData":JSON.parse(decodeProtocolData.value)
        };
        var objToSend={};
        for (element in fullObj) if (fullObj[element] != "") {
          objToSend[element] = fullObj[element];
        }
        var toSend = JSON.stringify([objToSend]);
        print("Sending request: " + toSend);
        ws.send(toSend);
        return false;
      };

      document.getElementById("close").onclick = function(evt) {
        if (!ws) {
          print("No websocket open; nothing to be done.");
                  return false;
                }
                ws.close();
                return false;
              };
            });
  </script>

</head>
<body>
  <p>Click "Open" to create a connection to the server, "Close" to close the connection,
    and "Send" to send a request to the server.
    You can change the request and send multiple times; closing will cancel any running pcap.
  </p>
<table>
  <tr>
    <td valign="top" width="25%">
    <form>
      <table>
        <tr><td><button id="open">Open</button></td>
        <td><button id="close">Close</button><br></td></tr>
        <tr><td><label for="requestID" >requestID:</label></td>
        <td><input id="requestID" type="text" value=""></td></tr>
        <tr><td><label for="filter">berkley packet filter:</label></td>
        <td><input id="filter" type="text" value=""></td></tr>
        <tr><td><label for="snapshotLen">max packet length:</label></td>
        <td><input id="snapshotLen" type="number" value=1538></td></tr>
        <tr><td><label for="promiscuous">capture promiscuously:</label></td>
        <td><input id="promiscuous" type="text" value="false"></td></tr>
        <tr><td><label for="timeout">timeout (in ns):</label></td>
        <td><input id="timeout" type="number" value="30000000000"></td></tr>
        <tr><td><label for="limit">number of packets:</label></td>
        <td><input id="limit" type="number" value="10"></td></tr>
        <tr><td><label for="ifaceToRead">interface to read:</label></td>
        <td><input id="ifaceToRead" type="text" value="en3"></td></tr>
        <tr><td><label for="readFile">read from file:</label></td>
        <td><input id="readFile" type="text" value=""></td></tr>
        <tr><td><label for="writeFile">save output to file:</label></td>
        <td><input id="writeFile" type="text" value=""></td></tr>
        <tr><td><label for="sendRawPacket">also send raw packet:</label></td>
        <td><input id="sendRawPacket" type="text" value="false"></td></tr>
        <tr><td><label for="sendMetadata">also send metadata:</label></td>
        <td><input id="sendMetadata" type="text" value="true"></td></tr>
        <tr><td><label for="decodePacket">decode packet data:</label></td>
        <td><input id="decodePacket" type="text" value="true"></td></tr>
        <tr><td><label for="decodeProtocolData">decode protocol data:</label></td>
        <td><input id="decodeProtocolData" type="text" value="true"></td></tr>
        <tr><td><button id="send">Send</button></td></tr>
      </table>
    </form>
    </td>
    <td valign="top" width="25%">
      <div id="output"></div>
    </td>
  </tr>
</table>
</body>
</html>
