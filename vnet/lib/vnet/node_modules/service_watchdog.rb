# -*- coding: utf-8 -*-

module Vnet
  module NodeModules
    class ServiceWatchdog
      include Celluloid
      include Celluloid::Logger
      include Vnet::Manager::Logger

      # finalizer :stop_watchdog
      # trap_exit :actor_died

      def initialize
        @log_prefix = 'watchdog: '

        @interval = Vnet::Configurations::Common.conf.watchdog_interval
        @timeout = Vnet::Configurations::Common.conf.watchdog_timeout

        @timer = nil
        @entries = {}
        @polling = []

        case Vnet::Configurations::Common.conf.watchdog_logging
        when 'error'
          @log_tick = true
          @log_tick_verbose = false
          @log_completed = false
          @log_completed_event_count = nil
        when 'debug'
          @log_tick = true
          @log_tick_verbose = true
          @log_completed = false
          @log_completed_event_count = 1
        else
          raise 'Invalid logging setting.'
        end

        super
      end

      def start_watchdog
        info log_format_h('starting watchdog service', interval: @interval)

        raise 'Watchdog service already running.' if @timer || !@polling.empty?

        @entries.each { |id, entry|
          a = entry[:actor]
          @polling << [id, a.future.watchdog_check]
        }

        @timer = after(@interval) { handle_timer }
        nil
      end

      def stop_watchdog
        info log_format('stopping watchdog service')
        nil
      end      

      def register_actor(id, actor)
        info log_format("registering #{id}")

        raise 'Invalid actor id type.' if !id.is_a? String || id.empty?

        @entries[id].tap { |entry|
          next if entry.nil?

          if entry[:actor] == actor
            raise "Actor registered with watchdog twice."
          end

          if !wait_entry_dead(entry)
            # Never reached, fix handling.
            raise "wait_entry_dead(entry) failed."
          end

          # Previously registerd actor is now dead, replace.
          @entries[id].tap { |current|
            if current && current[:actor] != entry[:actor]
              raise "Actor id '#{id}' registered while we were attempting to register."
            end

            @entries.delete(id)
          }
        }

        @entries[id] = {
          id: id,
          actor: actor,
          since_last: 0,
        }

        @polling << [id, actor.future.watchdog_check]
        nil
      end

      def unregister_actor(id, actor)
        @entries[id].tap { |entry|
          raise "Actor not registered: #{actor.inspect}" if !entry

          if entry[:actor] == actor
            info log_format("unregistering #{id}")

            @entries.delete(id)
          else
            info log_format("unregistering #{id}, already replaced by new actor")
          end
        }        

        nil
      end

      def actor_died(actor, reason)
        nil
      end

      #
      # Internal:
      #

      private

      def wait_entry_dead(entry, max_wait = 20)
        deadline = Time.now + max_wait

        # TODO: Set entry state.

        while Time.now < deadline
          @entries[entry[:id]].tap { |current|
            return true if current.nil? || current[:actor] != entry[:actor]
            return true if !entry[:actor].alive?
          }

          sleep(0.2)
        end

        # TODO: Improve this so vna or datapath is recreated.
        @entries[entry[:id]].tap { |current|
          next if current.nil? || current[:actor] != entry[:actor]

          info log_format("deleting entry #{entry[:id]}, timeout reached")
          @entries.delete(entry[:id]) 
        }

        raise "Actor id '#{entry[:id]}' already registered and did not get cleaned up in time."
      end

      def handle_timer
        debug log_format_h('handling watchdog timer', total: @entries.size, actors: @entries.keys.inspect) if @log_tick_verbose

        completed = []
        unresponsive = []

        # TODO: Change this to handle unregistered and dead actors.

        @polling.delete_if { |id, future|
          entry = @entries[id]
          raise 'Polling contains an unregistered actor.' if entry.nil?

          if future.ready?
            entry[:since_last] = 0
            next completed << [id, future]
          end

          entry[:since_last] += @interval

          if entry[:since_last] >= @timeout
            next unresponsive << [id, future]
          else
            nil
          end
        }

        completed.each { |id, future|
          entry = @entries[id]
          raise 'Completed contains an unregistered actor.' if entry.nil?

          begin
            future.value.tap { |value|
              handle_completed(id, entry, value)
            }

            @polling << [id, entry[:actor].future.watchdog_check]
          rescue Celluloid::DeadActorError
            handle_dead(id, entry)
          end
        }
        unresponsive.each { |id, future|
          entry = @entries[id]
          raise 'Unresponsive contains an unregistered actor.' if entry.nil?

          handle_unresponsive(id, entry)
        }

        debug log_format_h('completed watchdog timer', polling: @polling.size, completed: completed.size, unresponsive: unresponsive.size) if @log_tick

        @timer = after(@interval) { handle_timer }
      end

      def handle_completed(id, entry, value)
        print_log = @log_completed

        if @log_completed_event_count && value[:event_task_count] &&
           @log_completed_event_count <= value[:event_task_count]
          print_log = true
        end

        # TODO: Only print when value concerning results, e.g. high event_task_count.

        debug log_format_h('handling completed check', value) if print_log
      end

      def handle_unresponsive(id, entry)
        debug log_format_h('handling unresponsive actor', id: id, since_last: entry[:since_last])
      end

      def handle_dead(id, entry)
        debug log_format_h('handling dead actor', id: id)

        #future.cancel
      end

    end
  end
end
