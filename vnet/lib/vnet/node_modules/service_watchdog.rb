# -*- coding: utf-8 -*-

module Vnet
  module NodeModules
    class ServiceWatchdog
      include Celluloid
      include Celluloid::Logger
      include Vnet::Manager::Logger

      # finalizer :stop_watchdog
      # trap_exit :actor_died

      def initialize
        @log_prefix = 'service_watchdog: '

        @interval = 1
        @timeout = 3

        @timer = nil
        @entries = {}
        @polling = []

        super
      end

      def start_watchdog
        info log_format_h('starting watchdog service', interval: @interval)

        raise "Watchdog service already running." if @timer || !@polling.empty?

        @entries.each { |id, entry|
          entry[:actor].tap { |a|
            @polling << [id, a.future.watchdog_check]
          }
        }

        @timer = every(@interval) { handle_timer }
      end

      def stop_watchdog
        info log_format('stopping watchdog service')
      end      

      def register_actor(id, watching_actor)
        info log_format_h("registering #{id}", actor: watching_actor.inspect)

        raise "Invalid actor id type." if !id.is_a? String
        raise "Actor already registered." if @entries.has_key? id

        @entries[id] = {
          actor: watching_actor,
          since_last: 0,
        }

        @polling << [id, watching_actor.future.watchdog_check]

        # Monitor actor.
      end

      def unregister_actor(id, actor)
        info log_format("unregistering #{id}", actor: actor.inspect)

        @entries.delete(id).tap { |entry|
          raise "Actor not registered." if !entry
          raise "Actor does not match registered actor." if entry[:actor] != actor

          # Remove from watch queue.
        }
      end

      def actor_died(actor, reason)
      end

      private

      def handle_timer
        debug log_format_h('handling watchdog timer', total: @entries.size, actors: @entries.keys.inspect)

        completed = []
        unresponsive = []

        # TODO: Change this to handle unregistered and dead actors.

        @polling.delete_if { |id, future|
          entry = @entries[id]
          raise "Polling contains an unregistered actor." if entry.nil?

          if future.ready?
            entry[:since_last] = 0
            next completed << [id, future]
          end

          entry[:since_last] += @interval

          if entries[:since_last] >= @timeout
            next unresponsive << [id, future]
          end
        }

        completed.each { |id, future|
          entry = @entries[id]
          raise "Completed contains an unregistered actor." if entry.nil?

          entry[:actor].tap { |a|
            @polling << [id, a.future.watchdog_check]
          }

          handle_completed(id, entry, future)
        }
        unresponsive.each { |id, future|
          entry = @entries[id]
          raise "Unresponsive contains an unregistered actor." if entry.nil?

          handle_unresponsive(id, entry, future)
        }

        debug log_format_h('completed watchdog timer', polling: @polling.size)
      end

      def handle_completed(id, entry, future)
        value = future.value

        debug log_format_h('handling completed check', id: id, value: value.inspect)
      end

      def handle_unresponsive(id, entry, future)
        debug log_format_h('handling unresponsive actor', id: id)

        # future.cancel
      end

    end
  end
end
