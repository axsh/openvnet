# -*- coding: utf-8 -*-

module Vnet
  module NodeModules
    class ServiceWatchdog
      include Celluloid
      include Celluloid::Logger
      include Vnet::Manager::Logger

      # finalizer :stop_watchdog
      # trap_exit :actor_died

      def initialize
        @log_prefix = 'watchdog: '

        @interval = Vnet::Configurations::Common.conf.watchdog_interval
        @timeout = Vnet::Configurations::Common.conf.watchdog_timeout

        @timer = nil
        @entries = {}
        @polling = []

        case Vnet::Configurations::Common.conf.watchdog_logging
        when 'error'
          @log_tick = false
          @log_tick_verbose = false
          @log_completed = false
          @log_completed_event_count = nil
        when 'debug'
          @log_tick = true
          @log_tick_verbose = true
          @log_completed = false
          @log_completed_event_count = 1
        else
          raise 'Invalid logging setting.'
        end

        super
      end

      def start_watchdog
        info log_format_h('starting watchdog service', interval: @interval)

        raise 'Watchdog service already running.' if @timer || !@polling.empty?

        @entries.each { |id, entry|
          a = entry[:actor]
          @polling << [id, a.future.watchdog_check]
        }

        @timer = after(@interval) { handle_timer }
      end

      def stop_watchdog
        info log_format('stopping watchdog service')
      end      

      def register_actor(id, actor)
        info log_format("registering #{id}") #, actor: actor.inspect)

        raise 'Invalid actor id type.' if !id.is_a? String || id.empty?

        @entries[id].tap { |entry|
          next if entry.nil?
          raise "Actor id already registered, and actor #{entry[:actor] == actor ? "does" : "doesn't"} match."
        }
        
        @entries[id] = {
          actor: actor,
          since_last: 0,
        }

        @polling << [id, actor.future.watchdog_check]
      end

      def unregister_actor(id, actor)
        info log_format("unregistering #{id}", actor: actor.inspect)

        @entries.delete(id).tap { |entry|
          raise 'Actor not registered.' if !entry
          raise 'Actor does not match registered actor.' if entry[:actor] != actor

          # Remove from watch queue.
        }
      end

      def actor_died(actor, reason)
      end

      private

      def handle_timer
        debug log_format_h('handling watchdog timer', total: @entries.size, actors: @entries.keys.inspect) if @log_tick_verbose

        completed = []
        unresponsive = []

        # TODO: Change this to handle unregistered and dead actors.

        @polling.delete_if { |id, future|
          entry = @entries[id]
          raise 'Polling contains an unregistered actor.' if entry.nil?

          if future.ready?
            entry[:since_last] = 0
            next completed << [id, future]
          end

          entry[:since_last] += @interval

          if entry[:since_last] >= @timeout
            next unresponsive << [id, future]
          else
            nil
          end
        }

        completed.each { |id, future|
          entry = @entries[id]
          raise 'Completed contains an unregistered actor.' if entry.nil?

          begin
            future.value.tap { |value|
              handle_completed(id, entry, value)
            }

            entry[:actor].tap { |a|
              @polling << [id, a.future.watchdog_check]
            }
          rescue Celluloid::DeadActorError
            handle_dead(id, entry)
          end
        }
        unresponsive.each { |id, future|
          entry = @entries[id]
          raise 'Unresponsive contains an unregistered actor.' if entry.nil?

          handle_unresponsive(id, entry)
        }

        debug log_format_h('completed watchdog timer', polling: @polling.size, completed: completed.size, unresponsive: unresponsive.size) if @log_tick

        @timer = after(@interval) { handle_timer }
      end

      def handle_completed(id, entry, value)
        print_log = @log_completed

        if @log_completed_event_count && value[:event_task_count] &&
           @log_completed_event_count <= value[:event_task_count]
          print_log = true
        end

        # TODO: Only print when value concerning results, e.g. high event_task_count.

        debug log_format_h('handling completed check', value) if print_log
      end

      def handle_unresponsive(id, entry)
        debug log_format_h('handling unresponsive actor', id: id, since_last: entry[:since_last])
      end

      def handle_dead(id, entry)
        debug log_format_h('handling dead actor', id: id)

        #future.cancel
      end

    end
  end
end
