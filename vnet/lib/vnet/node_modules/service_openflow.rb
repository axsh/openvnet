# -*- coding: utf-8 -*-

require 'celluloid'
require 'nio'
require 'trema'

module Vnet
  module NodeModules

    class ServiceOpenflow
      include Celluloid
      include Celluloid::Notifications
      include Celluloid::Logger
      include Vnet::Event::Dispatchable

      def initialize
        # @command = Vnet::Openflow::Command.new
      end

      def start_openflow
        info "service_openflow: starting"

        conf = Vnet::Configurations::Vna.conf

        Phut.pid_dir = conf.trema_tmp + '/pid'
        Phut.log_dir = conf.trema_tmp + '/log'
        Phut.socket_dir = conf.trema_tmp + '/sock'

        %w(log pid sock).each do |name|
          FileUtils.mkdir_p(File.join(conf.trema_tmp, name))
        end

        Pio::OpenFlow.version = :OpenFlow13

        # command_args = {}
        # command_options = {}

        # @command = Vnet::Openflow::Command.new
        # @command.run(command_args, command_options)

        create_controller

        start_controller

        info "service_openflow: started"
      end

      def handle_exit
        info "service_openflow: terminating"

        # @command && @command.killall
      end

      def dispatch_publish(event, options)
        publish(event, options)
        nil
      end

      private

      def unix_domain_socket(name)
        path = File.expand_path(File.join(Phut.socket_dir, "#{name}.ctl"))

        'drbunix:' + path
      end

      def create_controller
        # Load our controller class to register it with Trema.
        Vnet::Openflow::Controller

        @controller = Trema::Controller.create(6633, :debug)
      end

      def start_controller
        DRb.start_service(unix_domain_socket(@controller.name), self)

        # @controller_thread = Thread.new { @controller.run [] }
        # @controller_thread.abort_on_exception = true

        @controller.run []

        DRb.thread.join

        # killall on rescue
      end

    end

  end
end
