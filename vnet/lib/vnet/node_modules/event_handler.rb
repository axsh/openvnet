# -*- coding: utf-8 -*-
module Vnet::NodeModules
  class EventHandler
    include Celluloid
    include Celluloid::Logger
    include Vnet::Event

    # TODO: Use a more efficient way of identifying vnmgr events, like
    # a prefix.
    VNMGR_EVENTS = [
      IP_RETENTION_CONTAINER_INITIALIZED,
      IP_RETENTION_CONTAINER_UNLOAD_ITEM,
      IP_RETENTION_CONTAINER_CREATED_ITEM,
      IP_RETENTION_CONTAINER_DELETED_ITEM,
      IP_RETENTION_CONTAINER_ADDED_IP_RETENTION,
      IP_RETENTION_CONTAINER_REMOVED_IP_RETENTION,
      IP_RETENTION_CONTAINER_LEASE_TIME_EXPIRED,
      IP_RETENTION_CONTAINER_GRACE_TIME_EXPIRED,
      TOPOLOGY_INITIALIZED,
      TOPOLOGY_UNLOAD_ITEM,
      TOPOLOGY_CREATED_ITEM,
      TOPOLOGY_DELETED_ITEM,
      TOPOLOGY_NETWORK_ACTIVATED,
      TOPOLOGY_NETWORK_DEACTIVATED,
      TOPOLOGY_ROUTE_LINK_ACTIVATED,
      TOPOLOGY_ROUTE_LINK_DEACTIVATED,
    ]

    attr_accessor :api

    def initialize
      # TODO determin which proxy should be used
      self.api = Vnet::NodeApi.set_proxy(:direct)
      @vna = []
    end

    def handle_event(event, options = {})
      # TODO use declarative style

      # TODO: Refactor.

      options = options.dup
      debug "handle_event: #{event} options: #{options}"

      case event
      when ADDED_DATAPATH_NETWORK
        datapath_network = api.datapath_network[options[:dpn_id]]
        publish_event(datapath_network.datapath.node_id, event, options)

        datapath_network.datapath_networks_in_the_same_network.each do |dpn|
          publish_event(dpn.datapath.node_id, event, options)
        end

      when REMOVED_DATAPATH_NETWORK
        datapath_network = api.datapath_network.with_deleted.first(id: options[:dpn_id])
        return unless datapath_network.deleted_at

        publish_event(datapath_network.datapath.node_id, event, options) if datapath_network.datapath

        datapath_network.datapath_networks_in_the_same_network.each do |dpn|
          publish_event(dpn.datapath.node_id, event, options)
        end

      when ADDED_DATAPATH_ROUTE_LINK
        datapath_route_link = api.datapath_route_link[options[:dprl_id]]
        publish_event(datapath_route_link.datapath.node_id, event, options)

        datapath_route_link.datapath_route_links_in_the_same_route_link.each do |dprl|
          publish_event(dprl.datapath.node_id, event, options)
        end

      when REMOVED_DATAPATH_ROUTE_LINK
        datapath_route_link = api.datapath_route_link.with_deleted.first(id: options[:dprl_id])
        return unless datapath_route_link.deleted_at

        publish_event(datapath_route_link.datapath.node_id, event, options) if datapath_route_link.datapath

        datapath_route_link.datapath_route_links_in_the_same_route_link.each do |dprl|
          publish_event(dprl.datapath.node_id, event, options)
        end

      when DATAPATH_CREATED_ITEM
        datapath = api.datapath[options[:id]]
        publish_event(datapath.node_id, event, options)

      when DATAPATH_DELETED_ITEM
        publish_event(options[:node_id], event, options)

        # Same as default case.
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end

      when *VNMGR_EVENTS
        debug "publish_event node_id: vnmgr event: #{event} options: #{options}"
        DCell::Node[:vnmgr][:vnmgr].publish(event, options)

      else
        # TODO: Refactor. We should not need to query for every single
        # event.
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end
      end
    end

    def publish_event(node_id, event, options)
      debug "publish_event node_id: #{node_id} event: #{event} options: #{options}"
      DCell::Node[node_id].tap do |node|
        unless node && node.state == :connected
          warn "node: #{node_id} is disconnected"
          next
        end

        unless node[:service_openflow]
          warn "node: #{node_id} has no service_openflow"
          next
        end

        node[:service_openflow].publish(event, options)
      end
    end
  end
end
