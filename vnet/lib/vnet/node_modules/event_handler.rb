# -*- coding: utf-8 -*-
module Vnet::NodeModules
  class EventHandler
    include Celluloid
    include Celluloid::Logger

    attr_accessor :api

    def initialize
      # TODO determin which proxy should be used
      self.api = Vnet::NodeApi.get_proxy(:direct)
      @vna = []
    end

    def handle_event(event, options = {})
      debug "handle_event: #{event} options: #{options}"
      case event
      # TODO refactoring
      when "vna_initialized"
        if not @vna.include?({:node => options[:node], :actor => options[:actor]})
          @vna << {:node => options[:node], :actor => options[:actor]}
        else
          error "vna :node = #{options[:node]} actor = #{options[:actor]} is already registered."
        end
      # TODO refactoring
      when "network/deleted"
        @vna.each do |v|
          DCell::Node[v[:node]][v[:actor]].async.update_topology(options[:network_id], options[:dpid])
        end
      when "network/vif_added"
        api.datapath.find_all_by_network_id(options[:network_id]).each do |datapath|
          debug "node_id: #{datapath[:node_id]}"
          # TODO implement me
          # ex) DCell::Node[datapath.node_id][:api].vif_added(options[:network_id], options[:vif_id])
        end
      when "network/vif_removed"
        api.datapath.find_all_by_network_id(options[:network_id]).each do |datapath|
          debug "node_id: #{datapath[:node_id]}"
          # TODO implement me
          # ex) DCell::Node[datapath.node_id][:api].vif_removed(options[:network_id], options[:vif_id])
        end
      end
    end
  end
end
