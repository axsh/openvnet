# -*- coding: utf-8 -*-
module Vnet::NodeModules
  class EventHandler
    include Celluloid
    include Celluloid::Logger
    include Vnet::Event

    # TODO: Use a more efficient way of identifying vnmgr events, like
    # a prefix.
    VNMGR_EVENTS = [
      IP_RETENTION_CONTAINER_INITIALIZED,
      IP_RETENTION_CONTAINER_UNLOAD_ITEM,
      IP_RETENTION_CONTAINER_CREATED_ITEM,
      IP_RETENTION_CONTAINER_DELETED_ITEM,
      IP_RETENTION_CONTAINER_ADDED_IP_RETENTION,
      IP_RETENTION_CONTAINER_REMOVED_IP_RETENTION,
      IP_RETENTION_CONTAINER_LEASE_TIME_EXPIRED,
      IP_RETENTION_CONTAINER_GRACE_TIME_EXPIRED,

      TOPOLOGY_INITIALIZED,
      TOPOLOGY_UNLOAD_ITEM,
      TOPOLOGY_CREATED_ITEM,
      TOPOLOGY_DELETED_ITEM,

      TOPOLOGY_NETWORK_ACTIVATED,
      TOPOLOGY_NETWORK_DEACTIVATED,
      TOPOLOGY_SEGMENT_ACTIVATED,
      TOPOLOGY_SEGMENT_DEACTIVATED,
      TOPOLOGY_ROUTE_LINK_ACTIVATED,
      TOPOLOGY_ROUTE_LINK_DEACTIVATED,

      TOPOLOGY_ADDED_DATAPATH,
      TOPOLOGY_REMOVED_DATAPATH,
      TOPOLOGY_ADDED_MAC_RANGE_GROUP,
      TOPOLOGY_REMOVED_MAC_RANGE_GROUP,
      TOPOLOGY_ADDED_LAYER,
      TOPOLOGY_REMOVED_LAYER,
      TOPOLOGY_ADDED_NETWORK,
      TOPOLOGY_REMOVED_NETWORK,
      TOPOLOGY_ADDED_SEGMENT,
      TOPOLOGY_REMOVED_SEGMENT,
      TOPOLOGY_ADDED_ROUTE_LINK,
      TOPOLOGY_REMOVED_ROUTE_LINK,
    ]

    attr_accessor :api

    def initialize
      # TODO determin which proxy should be used
      self.api = Vnet::NodeApi.set_proxy(:direct)
      @vna = []
    end

    def handle_event(event, options = {})
      # TODO use declarative style

      # TODO: Refactor.

      options = options.dup
      debug log_format_h("handle_event: #{event}", options)

      case event
      when DATAPATH_CREATED_ITEM
        datapath = api.datapath[options[:id]]
        publish_event(datapath.node_id, event, options)

      when DATAPATH_DELETED_ITEM
        publish_event(options[:node_id], event, options)

        # Same as default case.
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end

      when *VNMGR_EVENTS
        begin
          # debug log_format_h("publish_event->vnmgr: #{event}", options)

          if DCell.me.id == 'vnmgr'
            Celluloid::Actor[:vnmgr].dispatch_publish(event, options)
          else
            DCell::Node['vnmgr'][:vnmgr].dispatch_publish(event, options)
          end

        rescue Celluloid::DeadActorError => e
          info "publish_event->vnmgr: could not send #{event}, vnmgr actor is dead"
        end

      else
        # TODO: Refactor. We should not need to query for every single
        # event.
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end
      end
    end

    def publish_event(node_id, event, options)
      raise "tried to use non-string node_id '#{node_id.inspect}'" if !node_id.is_a? String

      begin
        if DCell.me.id == node_id
          # debug log_format_h("publish_event(local)->#{node_id}: #{event}", options)

          Celluloid::Actor[:service_openflow].dispatch_publish(event, options)
        else
          # debug log_format_h("publish_event(remote)->#{node_id}: #{event}", options)

          DCell::Node[node_id].tap { |node|
            # No need to log as a node being disconnected is normal.
            next if node.nil? || node.state != :connected

            if node[:service_openflow].nil?
              warn "publish_event->#{node_id}: no service_openflow registered"
              next
            end

            node[:service_openflow].dispatch_publish(event, options)
          }
        end

      rescue Celluloid::DeadActorError => e
        info "publish_event->#{node_id}: could not send #{event}, service_openflow actor is dead"
      end
    end

    private

    def log_format_h(message, values)
      values && values.map { |value|
        value.join(':')
      }.join(' ').tap { |str|
        return "#{message} (#{str})"
      }
    end

  end
end
