# -*- coding: utf-8 -*-
module Vnet::NodeModules
  class EventHandler
    include Celluloid
    include Celluloid::Logger
    include Vnet::Event

    # TODO: Use a more efficient way of identifying vnmgr events, like
    # a prefix.
    VNMGR_EVENTS = [
      IP_RETENTION_CONTAINER_INITIALIZED,
      IP_RETENTION_CONTAINER_UNLOAD_ITEM,
      IP_RETENTION_CONTAINER_CREATED_ITEM,
      IP_RETENTION_CONTAINER_DELETED_ITEM,
      IP_RETENTION_CONTAINER_ADDED_IP_RETENTION,
      IP_RETENTION_CONTAINER_REMOVED_IP_RETENTION,
      IP_RETENTION_CONTAINER_LEASE_TIME_EXPIRED,
      IP_RETENTION_CONTAINER_GRACE_TIME_EXPIRED,

      TOPOLOGY_INITIALIZED,
      TOPOLOGY_UNLOAD_ITEM,
      TOPOLOGY_CREATED_ITEM,
      TOPOLOGY_DELETED_ITEM,

      TOPOLOGY_NETWORK_ACTIVATED,
      TOPOLOGY_NETWORK_DEACTIVATED,
      TOPOLOGY_SEGMENT_ACTIVATED,
      TOPOLOGY_SEGMENT_DEACTIVATED,
      TOPOLOGY_ROUTE_LINK_ACTIVATED,
      TOPOLOGY_ROUTE_LINK_DEACTIVATED,

      TOPOLOGY_ADDED_DATAPATH,
      TOPOLOGY_REMOVED_DATAPATH,
      TOPOLOGY_ADDED_LAYER,
      TOPOLOGY_REMOVED_LAYER,
      TOPOLOGY_ADDED_NETWORK,
      TOPOLOGY_REMOVED_NETWORK,
      TOPOLOGY_ADDED_SEGMENT,
      TOPOLOGY_REMOVED_SEGMENT,
      TOPOLOGY_ADDED_ROUTE_LINK,
      TOPOLOGY_REMOVED_ROUTE_LINK,
    ]

    attr_accessor :api

    def initialize
      # TODO determin which proxy should be used
      self.api = Vnet::NodeApi.set_proxy(:direct)
      @vna = []
    end

    def handle_event(event, options = {})
      # TODO use declarative style

      # TODO: Refactor.

      options = options.dup
      debug log_format_h("handle_event: #{event}", options)

      case event
      when ADDED_DATAPATH_NETWORK
        datapath_network = api.datapath_network[options[:dpn_id]]
        publish_event(datapath_network.datapath.node_id, event, options)

        datapath_network.datapath_networks_in_the_same_network.each do |dp_gen|
          publish_event(dp_gen.datapath.node_id, event, options)
        end

      when REMOVED_DATAPATH_NETWORK
        datapath_network = api.datapath_network.with_deleted.first(id: options[:dpn_id])
        return unless datapath_network.deleted_at

        publish_event(datapath_network.datapath.node_id, event, options) if datapath_network.datapath

        datapath_network.datapath_networks_in_the_same_network.each do |dp_gen|
          publish_event(dp_gen.datapath.node_id, event, options)
        end

      when ADDED_DATAPATH_SEGMENT
        datapath_segment = api.datapath_segment[options[:dpseg_id]]
        publish_event(datapath_segment.datapath.node_id, event, options)

        datapath_segment.datapath_segments_in_the_same_segment.each do |dp_gen|
          publish_event(dp_gen.datapath.node_id, event, options)
        end

      when REMOVED_DATAPATH_SEGMENT
        datapath_segment = api.datapath_segment.with_deleted.first(id: options[:dpseg_id])
        return unless datapath_segment.deleted_at

        publish_event(datapath_segment.datapath.node_id, event, options) if datapath_segment.datapath

        datapath_segment.datapath_segments_in_the_same_segment.each do |dp_gen|
          publish_event(dp_gen.datapath.node_id, event, options)
        end

      when ADDED_DATAPATH_ROUTE_LINK
        datapath_route_link = api.datapath_route_link[options[:dprl_id]]
        publish_event(datapath_route_link.datapath.node_id, event, options)

        datapath_route_link.datapath_route_links_in_the_same_route_link.each do |dprl|
          publish_event(dprl.datapath.node_id, event, options)
        end

      when REMOVED_DATAPATH_ROUTE_LINK
        datapath_route_link = api.datapath_route_link.with_deleted.first(id: options[:dprl_id])
        return unless datapath_route_link.deleted_at

        publish_event(datapath_route_link.datapath.node_id, event, options) if datapath_route_link.datapath

        datapath_route_link.datapath_route_links_in_the_same_route_link.each do |dprl|
          publish_event(dprl.datapath.node_id, event, options)
        end

      when DATAPATH_CREATED_ITEM
        datapath = api.datapath[options[:id]]
        publish_event(datapath.node_id, event, options)

      when DATAPATH_DELETED_ITEM
        publish_event(options[:node_id], event, options)

        # Same as default case.
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end

      when *VNMGR_EVENTS
        # debug log_format_h("publish_event->vnmgr: #{event}", options)
        DCell::Node[:vnmgr][:vnmgr].publish(event, options)

      else
        # TODO: Refactor. We should not need to query for every single
        # event.
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end
      end
    end

    def publish_event(node_id, event, options)
      DCell::Node[node_id].tap { |node|
        # No need to log as a node being disconnected is normal.
        next if node.nil? || node.state != :connected

        # debug log_format_h("publish_event->#{node_id}: #{event}", options)

        if node[:service_openflow].nil?
          warn "publish_event->#{node_id}: no service_openflow registered"
          next
        end

        node[:service_openflow].publish(event, options)
      }
    end

    private

    def log_format_h(message, values)
      values && values.map { |value|
        value.join(':')
      }.join(' ').tap { |str|
        return "#{message} (#{str})"
      }
    end

  end
end
